\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}

\usepackage{tikz}
\usetikzlibrary{arrows}

\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{xfrac}

\title{Your Paper}
\author{You}

\begin{document}
\maketitle

\begin{abstract}
    Your abstract.
\end{abstract}

\section{Introduction}

The goal of this report is to illustrate the work done on a FFT simulator in for the CompMeth course in EURECOM.
The functions developed are able to compute the FFT of a given signal, changing the input signal type, amplitude, number of points and a some other parameters that will be described later.

\section{Code Explanation}
\subsection{taus.c}
The purpose of this file is to generate random variable starting from a seed. This seed could be either fixed or a randomly generated value.
\paragraph{modifications:}
As it was, the seed was generated from the current system time, down to a precision of 1 second. This is not exactly good as two consecutive simulations could run in less than one second and, as a consequence, show some correlation. This is the reason why now the random seed is initialized down to a precision of 1 microsecond.
Also, in order to have a full deterministic behavior, another initialization function is able to set the seed to a fixed value.

\subsection{rangen\_double.c}
This is used to generated normally distributed random value trough the function \textit{gaussdouble}.
\paragraph{modifications:}
This piece of code was originally not working because it was developed for a 32-bit machine. Fixing the data types solved this issue.

\subsection{complex.h}
This file contains the definitions of data types used in the entire project. These can be double precision floating point numbers, 32-bit integers or 16-bit integers.
\paragraph{modifications:}
Like the previous file, this was not fully portable too, due to machine-dependent data types. Setting \textit{int32\_t} and \textit{int16\_t} should fix this portability issue. 

\subsection{fixed\_point.c}
Here we define the functions used to compute fixed point saturated addition and multiplication. These functions are available both in a 16-bit and 25-bit version.
\paragraph{modifications:}
Nothing was changed here with the exception of data types.

\subsection{fft.c}
This is the main core of the application, where all the processing of the FFT is done. Each function will be separately covered in this section.


\subsubsection{Twiddle factor}
The functions:
\begin{itemize}
\item void twiddle(struct complex *W, int N, double stuff)
\item void twiddle\_fixed(struct complex16 *W, int N, double stuff)         
\item void twiddle\_fixed\_Q17(struct complex32 *W, int N, double stuff)
\end{itemize}
Are used to compute the twiddle factor. As the prototype indicates, each function is required whether we are using floating points, Q15 or Q24 representations.\\
Following these formula, it's straightforward to understand the computations done in this function and the role of the \textit{stuff} parameter.
$$X_k = \frac{1}{\sqrt{N}}\sum_{n=0}^{N-1} x_k W_N^{kn} $$
$$W_N^{kn} = e^{\frac{-j2\pi kn}{N}} = \cos{(2\pi kn)} - j\sin{(2\pi kn)}$$
$$\mathit{stuff} = kn$$


\subsubsection{Coefficients reordering}
The following functions are needed because after the computation of the radix 4 FFT butterfly, the coefficients are shuffled in a precise pattern.
Again there are three functions used depending on the data type:
\begin{itemize}
	\item bit\_r4\_reorder(struct complex *W, int N)
	\item bit\_r4\_reorder\_fixed\_Q15(struct complex16 *W, int N)
	\item bit\_r4\_reorder\_fixed\_Q24(struct complex32 *W, int N)
\end{itemize}






\tikzstyle{n}= [circle, fill, minimum size=4pt,inner sep=0pt, outer sep=0pt]
\tikzstyle{mul} = [circle,draw,inner sep=-1pt]

% Define two helper counters
\newcounter{x}\newcounter{y}
\begin{tikzpicture}[yscale=0.5, xscale=1.2, node distance=0.4cm, auto]
	% The strategy is to create nodes with names: N-column-row
	% Input nodes are named N-0-0 ... N-0-15
	% Output nodes are named N-10-0 ... N-10-15
	
	% Draw inputs
	\foreach \y in {0,...,3}
		\node[n, pin={[pin edge={latex'-,black}]left:$x(\y)$}]
			(N-0-\y) at (0,-\y) {};
	% Draw outputs
	\foreach \y / \idx in {	0/3,1/2,2/1,3/0}
		\node[n, pin={[pin edge={-latex',black}]right:$X(\idx)$}]
			(N-5-\y) at (4,-\y) {};
			
	\foreach \sourcey / \desty in {0/3,1/2,2/1,3/0}
	\path (N-0-\sourcey.east) edge[-] (N-5-\desty.west);
\end{tikzpicture}












\subsubsection{Radix 4 }
This is the core function where the FFT coefficients are actually calculated. The function is recursive, and calls itself back until no more splitting is possible( when there is only one butterfly left), every time cutting the number of iterations by \sfrac{1}{4}.
\begin{itemize}
	\item radix4(struct complex *x, int N)
	\item TODO
	\item TODO
\end{itemize}

\subsubsection{QAM input}
\subsubsection{distortion test}
\subsubsection{main}

\section{Code}
\subsection{complex.h}
\noindent\begin{minipage}{.45\textwidth}
    \begin{lstlisting}[caption=code 1 1,frame=tlrb, language=C]{Name}
    struct complex{
    double r;
    double i;
    };

    struct complex16
    {
    short r;
    short i;
};

    struct complex32
    {
    int r;
    int i;
};
    \end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
    \begin{lstlisting}[caption=code 2,frame=tlrb, language=C]{Name}
    struct complex{
        double r;
    double i;
};

    struct complex16{
        int16_t r;
    int16_t i;
};

    struct complex32{
        int32_t r;
    int32_t i;
};
    \end{lstlisting}
\end{minipage}




\subsection{fft.c}
\begin{lstlisting}[caption=code 3,frame=tlrb, language=C]{Name}
void twiddle(struct complex *W, int N, double stuff){
    W->r=cos(stuff*2.0*PI/(double)N);
    W->i=-sin(stuff*2.0*PI/(double)N);
}

void twiddle_fixed(struct complex16 *W, int N, double stuff){
    W->r=(int16_t)(32767.0*cos(stuff*2.0*PI/(double)N));
    W->i=(int16_t)(-32768.0*sin(stuff*2.0*PI/(double)N));
    }

void twiddle_fixed_Q17(struct complex32 *W, int N, double stuff){
    W->r=(int32_t)(131071.0*cos(stuff*2.0*PI/(double)N));
W->i=(int32_t)(-131072.0*sin(stuff*2.0*PI/(double)N));
}
\end{lstlisting}

\noindent\begin{minipage}{.45\textwidth}
    \begin{lstlisting}[caption=code 4,frame=tlrb, language=C]{Name}
void bit_r4_reorder_fixed_Q15(
struct complex16 *W,
int N,
char scale)
{
  int bits, i, j, k;
  int16_t tempr, tempi;

  for(i=0; i<N; i++){
    W[i].r=W[i].r>>scale;
	W[i].i=W[i].i>>scale;
	}

  for (i=0; i<MAXPOW; i++)
  	if (pow_2[i]==N) bits=i;

  for (i=0; i<N; i++){
  	j=0;
   	for (k=0; k<bits; k+=2){
   	...
   	}

	if (j>i){
	  tempr=W[i].r;
	  tempi=W[i].i;
	  W[i].r=W[j].r;
	  W[i].i=W[j].i;
	  W[j].r=tempr;
	  W[j].i=tempi;
	  }
	}
  }
    \end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
    \begin{lstlisting}[caption=code 5,frame=tlrb, language=C]{Name}
void bit_r4_reorder_fixed_Q15(
struct complex16 *W,
int N,
char scale)
{
  int bits, i, j, k;
  short tempr, tempi;







for (i=0; i<MAXPOW; i++)
if (pow_2[i]==N) bits=i;

for (i=0; i<N; i++){
    j=0;
for (k=0; k<bits; k+=2){
    ...
}

if (j>i){
    tempr=W[i].r>>scale;
tempi=W[i].i>>scale;
W[i].r=W[j].r>>scale;
W[i].i=W[j].i>>scale;
W[j].r=tempr;
W[j].i=tempi;
}
}
}

    \end{lstlisting}
\end{minipage}

\begin{lstlisting}[caption=code 5,frame=tlrb, language=C]{Name}
void radix4_fixed_Q15(struct complex16 *x,   // Input in Q15 format
int N,                 // Size of FFT
unsigned char *scale,  // Pointer to scaling schedule
unsigned char stage)   // Stage of fft
{
int    n2, k1, N1, N2;
struct complex16 W, bfly[4];

N1=4;
N2=N/4;

// Do 4 Point DFT
for (n2=0; n2<N2; n2++){
    // scale Butterfly input
x[n2].r          >>= scale[stage];
x[N2+n2].r       >>= scale[stage];
x[(2*N2) + n2].r >>= scale[stage];
x[(3*N2) + n2].r >>= scale[stage];
x[n2].i          >>= scale[stage];
x[N2+n2].i       >>= scale[stage];
x[(2*N2) + n2].i >>= scale[stage];
x[(3*N2) + n2].i >>= scale[stage];

// Radix 4 Butterfly
bfly[0].r = SAT_ADD16(  SAT_ADD16(x[n2].r, x[N2 + n2].r) ,
            SAT_ADD16(x[2*N2+n2].r, x[3*N2+n2].r)
);
bfly[0].i = SAT_ADD16(  SAT_ADD16(x[n2].i, x[N2 + n2].i) ,
            SAT_ADD16(x[2*N2+n2].i, x[3*N2+n2].i)
);
bfly[1].r = SAT_ADD16(  SAT_ADD16(x[n2].r, x[N2 + n2].i) ,
           -SAT_ADD16(x[2*N2+n2].r, x[3*N2+n2].i)
);
bfly[1].i = SAT_ADD16(  SAT_ADD16(x[n2].i, -x[N2 + n2].r) ,
            SAT_ADD16(-x[2*N2+n2].i, x[3*N2+n2].r)
);
bfly[2].r = SAT_ADD16(  SAT_ADD16(x[n2].r, -x[N2 + n2].r) ,
            SAT_ADD16(x[2*N2+n2].r, -x[3*N2+n2].r)
);
bfly[2].i = SAT_ADD16(  SAT_ADD16(x[n2].i, -x[N2 + n2].i) ,
            SAT_ADD16(x[2*N2+n2].i, -x[3*N2+n2].i)
);
bfly[3].r = SAT_ADD16(  SAT_ADD16(x[n2].r, -x[N2 + n2].i) ,
            SAT_ADD16(-x[2*N2+n2].r, x[3*N2+n2].i)
);
bfly[3].i = SAT_ADD16(  SAT_ADD16(x[n2].i, x[N2 + n2].r) ,
            SAT_ADD16(-x[2*N2+n2].i, -x[3*N2+n2].r)
);

// In-place results
x[n2].r = bfly[0].r;
x[n2].i = bfly[0].i;

for (k1=1; k1<N1; k1++){
    twiddle_fixed(&W, N, (double)k1*(double)n2);
    x[n2 + N2*k1].r = SAT_ADD16( FIX_MPY(bfly[k1].r, W.r) ,
                     -FIX_MPY(bfly[k1].i, W.i) );
    x[n2 + N2*k1].i = SAT_ADD16( FIX_MPY(bfly[k1].i, W.r) ,
                      FIX_MPY(bfly[k1].r, W.i) );
}
}

// Don't recurse if we're down to one butterfly
if (N2!=1)
for (k1=0; k1<N1; k1++){
    radix4_fixed_Q15(&x[N2*k1], N2,scale,stage+1);
}
}
\end{lstlisting}

\bibliographystyle{alpha}
\bibliography{sample}

\end{document}
