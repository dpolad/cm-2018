\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{xfrac}

\title{Your Paper}
\author{You}

\begin{document}
\maketitle

\begin{abstract}
    Your abstract.
\end{abstract}

\section{Introduction}

The goal of this report is to illustrate the work done on a FFT simulator in for the CompMeth course in EURECOM.
The functions developed are able to compute the FFT of a given signal, changing the input signal type, amplitude, number of points and a some other parameters that will be described later.

\section{Code Explanation}
\subsection{taus.c}
The purpose of this file is to generate random variable starting from a seed. This seed could be either fixed or a randomly generated value.

\subsection{rangen\_double.c}
This is used to generated normally distributed random value trough the function \textit{gaussdouble}.

\subsection{complex.h}
This file contains the definitions of data types used in the entire project. These can be double precision floating point numbers, 32-bit integers or 16-bit integers.

\subsection{fixed\_point.c}
Here we define the functions used to compute fixed point saturated addition and multiplication. these functions are available both in a 16-bit and 25-bit version.

\subsection{fft.c}
This is the main core of the application, where all the processing of the FFT is done. Each function will be separately covered in this section.

\subsubsection{twiddle factor}
The functions:
\begin{itemize}
\item void twiddle(struct complex *W, int N, double stuff)
\item void twiddle\_fixed(struct complex16 *W, int N, double stuff)         
\item void twiddle\_fixed\_Q17(struct complex32 *W, int N, double stuff)
\end{itemize}

Are used to computed the twiddle factor. The parameter stuff is INSERT HERE. As the prototype indicates, each function is required whether we are using floating points, Q15 or Q24 representations.

\subsubsection{radix coefficients reordering}
Again there are three functions used depending on the data type:
\begin{itemize}
	\item bit\_r4\_reorder(struct complex *W, int N)
	\item bit\_r4\_reorder\_fixed\_Q15(struct complex16 *W, int N)
	\item bit\_r4\_reorder\_fixed\_Q24(struct complex32 *W, int N)
\end{itemize}
These functions are needed because after the computation of the radix 4 fft butterfly, the coefficients are shuffled in a precise pattern.

\subsubsection{radix 4 }
This is the core function where the FFT coefficients are actually calculated. The function is recursive, and calls itself back until only one butterfly is left, every time cutting the number of iterations by \sfrac{1}{4} (here comes the radix 4).
\begin{itemize}
	\item radix4(struct complex *x, int N)
	\item TODO
	\item TODO
\end{itemize}

\subsubsection{QAM input}
\subsubsection{distortion test}
\subsubsection{main}

\section{Code}
\subsection{complex.h}
\noindent\begin{minipage}{.45\textwidth}
    \begin{lstlisting}[caption=code 1 1,frame=tlrb, language=C]{Name}
    struct complex{
    double r;
    double i;
    };

    struct complex16
    {
    short r;
    short i;
};

    struct complex32
    {
    int r;
    int i;
};
    \end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
    \begin{lstlisting}[caption=code 2,frame=tlrb, language=C]{Name}
    struct complex{
        double r;
    double i;
};

    struct complex16{
        int16_t r;
    int16_t i;
};

    struct complex32{
        int32_t r;
    int32_t i;
};
    \end{lstlisting}
\end{minipage}




\subsection{fft.c}
\begin{lstlisting}[caption=code 3,frame=tlrb, language=C]{Name}
void twiddle(struct complex *W, int N, double stuff){
    W->r=cos(stuff*2.0*PI/(double)N);
    W->i=-sin(stuff*2.0*PI/(double)N);
}

void twiddle_fixed(struct complex16 *W, int N, double stuff){
    W->r=(int16_t)(32767.0*cos(stuff*2.0*PI/(double)N));
    W->i=(int16_t)(-32768.0*sin(stuff*2.0*PI/(double)N));
    }

void twiddle_fixed_Q17(struct complex32 *W, int N, double stuff){
    W->r=(int32_t)(131071.0*cos(stuff*2.0*PI/(double)N));
W->i=(int32_t)(-131072.0*sin(stuff*2.0*PI/(double)N));
}
\end{lstlisting}

\noindent\begin{minipage}{.45\textwidth}
    \begin{lstlisting}[caption=code 4,frame=tlrb, language=C]{Name}
void bit_r4_reorder_fixed_Q15(
struct complex16 *W,
int N,
char scale)
{
  int bits, i, j, k;
  int16_t tempr, tempi;

  for(i=0; i<N; i++){
    W[i].r=W[i].r>>scale;
	W[i].i=W[i].i>>scale;
	}

  for (i=0; i<MAXPOW; i++)
  	if (pow_2[i]==N) bits=i;

  for (i=0; i<N; i++){
  	j=0;
   	for (k=0; k<bits; k+=2){
   	...
   	}

	if (j>i){
	  tempr=W[i].r;
	  tempi=W[i].i;
	  W[i].r=W[j].r;
	  W[i].i=W[j].i;
	  W[j].r=tempr;
	  W[j].i=tempi;
	  }
	}
  }
    \end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
    \begin{lstlisting}[caption=code 5,frame=tlrb, language=C]{Name}
void bit_r4_reorder_fixed_Q15(
struct complex16 *W,
int N,
char scale)
{
  int bits, i, j, k;
  short tempr, tempi;







for (i=0; i<MAXPOW; i++)
if (pow_2[i]==N) bits=i;

for (i=0; i<N; i++){
    j=0;
for (k=0; k<bits; k+=2){
    ...
}

if (j>i){
    tempr=W[i].r>>scale;
tempi=W[i].i>>scale;
W[i].r=W[j].r>>scale;
W[i].i=W[j].i>>scale;
W[j].r=tempr;
W[j].i=tempi;
}
}
}

    \end{lstlisting}
\end{minipage}

\begin{lstlisting}[caption=code 5,frame=tlrb, language=C]{Name}
void radix4_fixed_Q15(struct complex16 *x,   // Input in Q15 format
int N,                 // Size of FFT
unsigned char *scale,  // Pointer to scaling schedule
unsigned char stage)   // Stage of fft
{
int    n2, k1, N1, N2;
struct complex16 W, bfly[4];

N1=4;
N2=N/4;

// Do 4 Point DFT
for (n2=0; n2<N2; n2++){
    // scale Butterfly input
x[n2].r          >>= scale[stage];
x[N2+n2].r       >>= scale[stage];
x[(2*N2) + n2].r >>= scale[stage];
x[(3*N2) + n2].r >>= scale[stage];
x[n2].i          >>= scale[stage];
x[N2+n2].i       >>= scale[stage];
x[(2*N2) + n2].i >>= scale[stage];
x[(3*N2) + n2].i >>= scale[stage];

// Radix 4 Butterfly
bfly[0].r = SAT_ADD16(  SAT_ADD16(x[n2].r, x[N2 + n2].r) ,
            SAT_ADD16(x[2*N2+n2].r, x[3*N2+n2].r)
);
bfly[0].i = SAT_ADD16(  SAT_ADD16(x[n2].i, x[N2 + n2].i) ,
            SAT_ADD16(x[2*N2+n2].i, x[3*N2+n2].i)
);
bfly[1].r = SAT_ADD16(  SAT_ADD16(x[n2].r, x[N2 + n2].i) ,
           -SAT_ADD16(x[2*N2+n2].r, x[3*N2+n2].i)
);
bfly[1].i = SAT_ADD16(  SAT_ADD16(x[n2].i, -x[N2 + n2].r) ,
            SAT_ADD16(-x[2*N2+n2].i, x[3*N2+n2].r)
);
bfly[2].r = SAT_ADD16(  SAT_ADD16(x[n2].r, -x[N2 + n2].r) ,
            SAT_ADD16(x[2*N2+n2].r, -x[3*N2+n2].r)
);
bfly[2].i = SAT_ADD16(  SAT_ADD16(x[n2].i, -x[N2 + n2].i) ,
            SAT_ADD16(x[2*N2+n2].i, -x[3*N2+n2].i)
);
bfly[3].r = SAT_ADD16(  SAT_ADD16(x[n2].r, -x[N2 + n2].i) ,
            SAT_ADD16(-x[2*N2+n2].r, x[3*N2+n2].i)
);
bfly[3].i = SAT_ADD16(  SAT_ADD16(x[n2].i, x[N2 + n2].r) ,
            SAT_ADD16(-x[2*N2+n2].i, -x[3*N2+n2].r)
);

// In-place results
x[n2].r = bfly[0].r;
x[n2].i = bfly[0].i;

for (k1=1; k1<N1; k1++){
    twiddle_fixed(&W, N, (double)k1*(double)n2);
    x[n2 + N2*k1].r = SAT_ADD16( FIX_MPY(bfly[k1].r, W.r) ,
                     -FIX_MPY(bfly[k1].i, W.i) );
    x[n2 + N2*k1].i = SAT_ADD16( FIX_MPY(bfly[k1].i, W.r) ,
                      FIX_MPY(bfly[k1].r, W.i) );
}
}

// Don't recurse if we're down to one butterfly
if (N2!=1)
for (k1=0; k1<N1; k1++){
    radix4_fixed_Q15(&x[N2*k1], N2,scale,stage+1);
}
}
\end{lstlisting}

\bibliographystyle{alpha}
\bibliography{sample}

\end{document}
